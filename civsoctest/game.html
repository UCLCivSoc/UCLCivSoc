<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CIVSOC ARCADE // TIME ATTACK</title>
<link rel="icon" type="image/png" href="images/website/civsoclogo.png">
<link rel="apple-touch-icon" href="images/website/civsoclogo.png">

    <style>
        :root {
            --neon-blue: #4fc3f7;
            --dark-bg: #050e1a;
            --panel-bg: #0b1d2e;
        }

        body {
            margin: 0; overflow: hidden; background-color: var(--dark-bg);
            font-family: 'Courier New', monospace; color: white;
            display: flex; height: 100vh; width: 100vw;
            user-select: none;
        }

        /* --- SIDEBAR --- */
        #sidebar {
            width: 300px; background: var(--panel-bg);
            border-right: 2px solid var(--neon-blue);
            padding: 30px; display: flex; flex-direction: column;
            box-shadow: 10px 0 30px rgba(0,0,0,0.5);
            z-index: 50; flex-shrink: 0;
        }
        h1 { font-size: 1.2rem; margin: 0 0 20px 0; color: var(--neon-blue); text-transform: uppercase; letter-spacing: 2px; border-bottom: 1px solid var(--neon-blue); padding-bottom: 10px; }
        h2 { font-size: 1rem; margin: 30px 0 10px 0; color: #aaa; }

        .stat-box {
            background: rgba(255,255,255,0.05); padding: 15px; margin-bottom: 10px;
            border-radius: 4px; border: 1px solid rgba(255,255,255,0.1);
        }
        .stat-label { font-size: 0.7rem; color: #888; display: block; margin-bottom: 5px; text-transform: uppercase; }
        .stat-value { font-size: 1.5rem; font-weight: 900; color: #fff; }
        .stat-value.timer { color: #ffeb3b; }
        .stat-value.score { color: #00e676; }

        #leaderboard-list { list-style: none; padding: 0; margin: 0; overflow-y: auto; flex-grow: 1; }
        #leaderboard-list li { display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px dashed #333; font-size: 0.85rem; }
        #leaderboard-list li:first-child { color: #FFD700; font-weight: bold; } 

        /* --- GAME AREA --- */
        #game-wrapper {
            flex-grow: 1; position: relative;
            background-image: radial-gradient(rgba(79, 195, 247, 0.1) 1px, transparent 1px);
            background-size: 20px 20px;
            cursor: default; 
            padding: 20px; display: flex; justify-content: center; align-items: center;
        }

        #game-container {
            width: 100%; height: 100%; position: relative;
            border: 1px solid rgba(79, 195, 247, 0.3);
            background: rgba(11, 29, 46, 0.8);
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            overflow: hidden;
        }
        
        canvas { display: block; width: 100%; height: 100%; }

        /* --- OVERLAYS --- */
        #start-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: rgba(11, 29, 46, 0.4); cursor: pointer; z-index: 20;
            transition: opacity 0.2s;
            pointer-events: none; /* Let clicks pass through to Global Listener */
        }
        #start-overlay h3 { font-size: 4rem; margin: 0; color: white; text-shadow: 0 5px 0 #000; }
        #start-overlay p { font-size: 1.5rem; font-weight: bold; background: rgba(0,0,0,0.8); padding: 5px 15px; display: inline-block;}

        #level-up-msg {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; pointer-events: none; transition: opacity 0.2s; opacity: 0; width: 100%; z-index: 5;
        }
        #level-up-msg h3 { font-size: 4rem; margin: 0; color: #00e676; text-shadow: 0 5px 0 #000; }
        #level-up-msg p { font-size: 1.5rem; font-weight: bold; color: white; }

        #game-over-screen {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 14, 26, 0.95);
            justify-content: center; align-items: center; flex-direction: column;
            z-index: 60; pointer-events: auto; cursor: default;
        }
        
        /* BUTTONS */
        .btn-corner {
            position: absolute; top: 30px; right: 30px; pointer-events: auto; z-index: 90;
            display: flex; gap: 15px;
        }
        .game-btn {
            background: rgba(0, 0, 0, 0.6); color: rgba(255,255,255,0.7);
            border: 1px solid rgba(255,255,255,0.3); padding: 8px 16px; 
            font-weight: bold; cursor: pointer; transition: all 0.2s;
            font-family: 'Courier New', monospace; font-size: 0.8rem; text-decoration: none;
        }
        .game-btn:hover { background: white; color: #000; }

        .restart-btn {
            background: var(--neon-blue); color: #000; border: none; padding: 15px 40px;
            font-family: 'Courier New', monospace; font-weight: 900; font-size: 1.2rem;
            cursor: pointer; margin-top: 20px; text-transform: uppercase; 
        }
        .restart-btn:hover { transform: scale(1.05); box-shadow: 0 0 20px var(--neon-blue); }

        #flash {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: white; opacity: 0; pointer-events: none; z-index: 15; transition: opacity 0.1s;
        }
        #powerup-text {
            position: absolute; top: 60%; left: 50%; transform: translate(-50%, -50%);
            font-size: 2rem; font-weight: 900; color: yellow; pointer-events: none;
            opacity: 0; transition: opacity 0.2s; text-shadow: 0 5px 0 #000; z-index: 5;
        }
    </style>
</head>
<body>

    <div id="sidebar">
        <h1>CIVSOC ARCADE</h1>
        <div class="stat-box">
            <span class="stat-label">Time Limit</span>
            <div class="stat-value timer" id="ui-timer">90</div>
        </div>
        <div class="stat-box">
            <span class="stat-label">Score</span>
            <div class="stat-value score" id="ui-score">0</div>
        </div>
        <div class="stat-box">
            <span class="stat-label">Lives</span>
            <div class="stat-value" id="lives-disp" style="color: #ff4444;">‚ù§‚ù§‚ù§</div>
        </div>
        <h2>LEADERBOARD</h2>
        <ul id="leaderboard-list"></ul>
    </div>

    <div id="game-wrapper">
        <div class="btn-corner">
            <button class="game-btn" id="mute-btn" onclick="toggleAudio()">üîà MUTE</button>
            <a href="index.html" class="game-btn">EXIT TO SITE</a>
        </div>

        <div id="game-container">
            <canvas id="gameCanvas"></canvas>
            
            <div id="start-overlay">
                <h3>READY?</h3>
                <p>[ CLICK ANYWHERE TO LAUNCH ]</p>
            </div>
    
            <div id="level-up-msg" class="overlay-msg">
                <h3>CLEARED!</h3>
                <p>+45 SECONDS</p>
            </div>
    
            <div id="game-over-screen">
                <h1 style="font-size: 3rem; color: #ff4444; margin-bottom: 10px;">GAME OVER</h1>
                <p style="font-size: 1rem; color: #888; margin-bottom: 20px;">TIME EXPIRED OR STRUCTURAL FAILURE</p>
                <p style="font-size: 1.5rem;">FINAL SCORE: <span id="final-score-display">0</span></p>
                <button class="restart-btn" onclick="resetGame()">TRY AGAIN</button>
            </div>
    
            <div id="flash"></div>
            <div id="powerup-text">POWER UP!</div>
        </div>
    </div>

    <script>
        /* =========================================
           1. AUDIO ENGINE
           ========================================= */
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx;
        let isMuted = false;
        let musicInterval;

        function initAudio() {
            try {
                if (!audioCtx) audioCtx = new AudioContext();
                if (audioCtx.state === 'suspended') audioCtx.resume();
            } catch(e) {}
        }

        function toggleAudio() {
            isMuted = !isMuted;
            document.getElementById('mute-btn').innerText = isMuted ? "üîá UNMUTE" : "üîà MUTE";
            if(isMuted) {
                clearInterval(musicInterval);
                musicInterval = null;
            } else {
                if(!musicInterval) startMusic();
            }
        }

        function playTone(freq, type, duration, vol = 0.1) {
            if (isMuted || !audioCtx) return;
            try {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + duration);
            } catch(e){}
        }

        function startMusic() {
            if(musicInterval) clearInterval(musicInterval);
            const notes = [110, 130, 146, 164, 146, 130]; 
            let idx = 0;
            musicInterval = setInterval(() => {
                if(isMuted) return;
                playTone(notes[idx], 'triangle', 0.4, 0.05);
                idx = (idx + 1) % notes.length;
            }, 400);
        }

        function sfxHitPaddle() { playTone(200, 'triangle', 0.1, 0.2); }
        function sfxHitBrick() { playTone(400 + Math.random()*200, 'square', 0.05, 0.1); }
        function sfxLifeLost() { 
            setTimeout(() => playTone(150, 'sawtooth', 0.3, 0.3), 0);
            setTimeout(() => playTone(100, 'sawtooth', 0.5, 0.3), 200);
        }
        function sfxPowerUp(good) { 
            if(good) {
                setTimeout(() => playTone(600, 'sine', 0.1, 0.2), 0);
                setTimeout(() => playTone(800, 'sine', 0.1, 0.2), 100);
            } else {
                playTone(150, 'sawtooth', 0.4, 0.2);
            }
        }

        /* =========================================
           2. GAME ENGINE
           ========================================= */
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('game-container');
        const wrapper = document.getElementById('game-wrapper');
        const startOverlay = document.getElementById('start-overlay');

        let animationId;
        let score = 0;
        let lives = 3;
        let timeLeft = 90;
        let level = 1;
        let gameRunning = false; 
        let gameActive = false;  
        let timerInterval;

        const ball = { x: 0, y: 0, r: 6, dx: 0, dy: 0, baseSpeed: 7, speed: 7, active: false };
        const paddle = { width: 120, height: 12, x: 0, y: 0, color: '#4fc3f7', baseWidth: 120 };
        let bricks = [];
        let particles = [];
        
        const brickRows = 5;
        const brickPadding = 8;
        const brickHeight = 20;
        const brickOffsetTop = 60;

        function resize() {
            const rect = container.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            
            if(canvas.width > 0) {
               if(!gameActive) resetBallPaddle(); 
               if(!gameRunning) initBricks(); 
            }
        }
        // Wait for layout paint
        setTimeout(resize, 100);
        window.addEventListener('resize', resize);

        function initBricks() {
            bricks = [];
            if(canvas.width === 0) return;

            const availableWidth = canvas.width - 40; 
            const brickWidth = 50;
            const cols = Math.floor(availableWidth / (brickWidth + brickPadding));
            const startX = (canvas.width - (cols * (brickWidth + brickPadding)) + brickPadding) / 2;

            for(let c=0; c<cols; c++) {
                for(let r=0; r<brickRows; r++) {
                    let type = 'REGULAR';
                    let color = `hsl(${200 + r * 15}, 70%, 50%)`;
                    let hp = 1;
                    const rand = Math.random();
                    if (r < 2 && rand > 0.75) { type = 'HARD'; color = '#888'; hp = 2; }
                    else if (rand > 0.92) { type = 'BONUS'; color = '#00e676'; }
                    else if (rand > 0.95) { type = 'MALUS'; color = '#ff4444'; }
                    else if (rand > 0.98) { type = 'MYSTERY'; color = '#d05ce3'; }

                    bricks.push({
                        x: startX + c * (brickWidth + brickPadding),
                        y: brickOffsetTop + r * (brickHeight + brickPadding),
                        w: brickWidth, h: brickHeight,
                        status: 1, hp: hp, type: type, color: color
                    });
                }
            }
        }

        function handlePowerUp(type) {
            const txt = document.getElementById('powerup-text');
            txt.style.opacity = 1;
            
            if(type === 'BONUS') {
                ball.speed = Math.max(5, ball.speed - 2);
                txt.innerText = "SLOW DOWN";
                txt.style.color = "#00e676";
                sfxPowerUp(true);
            }
            else if(type === 'MALUS') {
                ball.speed += 3;
                txt.innerText = "SPEED UP!";
                txt.style.color = "#ff4444";
                sfxPowerUp(false);
            }
            else if(type === 'MYSTERY') {
                const effects = ['wide', 'shrink', 'time', 'points'];
                const eff = effects[Math.floor(Math.random() * effects.length)];
                
                if(eff === 'wide') {
                    paddle.width = paddle.baseWidth + 50;
                    txt.innerText = "WIDE PADDLE";
                } else if(eff === 'shrink') {
                    paddle.width = 60;
                    txt.innerText = "TINY PADDLE";
                } else if(eff === 'time') {
                    timeLeft += 15;
                    txt.innerText = "+15 SECONDS";
                } else if(eff === 'points') {
                    score += 500;
                    txt.innerText = "+500 PTS";
                }
                txt.style.color = "#d05ce3";
                sfxPowerUp(true);
            }

            setTimeout(() => txt.style.opacity = 0, 1000);
        }

        function resetBallPaddle() {
            paddle.x = (canvas.width - paddle.width) / 2;
            paddle.y = canvas.height - 40;
            
            ball.active = false;
            ball.x = paddle.x + paddle.width / 2;
            ball.y = paddle.y - ball.r - 1; 
            ball.dx = 0; ball.dy = 0;
            
            wrapper.style.cursor = "default";
        }

        function startGame() {
            initAudio(); // Unlock audio
            
            startOverlay.style.display = 'none';
            wrapper.style.cursor = "none";
            
            if(!gameActive) {
                gameActive = true;
                timerInterval = setInterval(() => {
                    if(timeLeft > 0) {
                        timeLeft--;
                        updateUI();
                    } else {
                        endGame();
                    }
                }, 1000);
            }

            ball.active = true;
            ball.speed = ball.baseSpeed + (level * 0.5);
            ball.dx = (Math.random() - 0.5) * 8;
            ball.dy = -ball.speed;
        }

        function updateUI() {
            document.getElementById('ui-score').innerText = score;
            document.getElementById('ui-timer').innerText = timeLeft;
            let hearts = ""; for(let i=0; i<lives; i++) hearts += "‚ù§";
            document.getElementById('lives-disp').innerText = hearts;
            document.getElementById('ui-timer').style.color = timeLeft <= 10 ? '#ff4444' : '#ffeb3b';
        }

        // --- MAIN LOOP ---
        function loop() {
            ctx.fillStyle = '#0b1d2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if(canvas.width === 0) {
                requestAnimationFrame(loop);
                return;
            }

            // Draw Bricks
            bricks.forEach(b => {
                if(b.status === 1) {
                    ctx.fillStyle = b.color;
                    if(b.type === 'HARD' && b.hp === 1) ctx.fillStyle = '#444'; 
                    ctx.fillRect(b.x, b.y, b.w, b.h);
                    ctx.strokeStyle = "rgba(255,255,255,0.1)";
                    ctx.strokeRect(b.x, b.y, b.w, b.h);
                }
            });

            // Draw Paddle
            ctx.fillStyle = paddle.color;
            ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);

            // Draw Ball
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
            ctx.fillStyle = "#fff";
            ctx.fill();
            ctx.closePath();

            // Particles
            particles.forEach((p, index) => {
                p.x += p.dx; p.y += p.dy; p.life -= 0.05;
                ctx.fillStyle = p.color; ctx.globalAlpha = p.life;
                ctx.fillRect(p.x, p.y, 3, 3);
                ctx.globalAlpha = 1;
                if(p.life <= 0) particles.splice(index, 1);
            });

            // PHYSICS
            if(ball.active && !gameOver) {
                if(ball.speed > 15) ball.speed = 15;
                ball.x += ball.dx;
                ball.y += ball.dy;

                // Walls
                if(ball.x + ball.r > canvas.width) { ball.x = canvas.width - ball.r; ball.dx = -ball.dx; sfxHitPaddle(); }
                else if(ball.x - ball.r < 0) { ball.x = ball.r; ball.dx = -ball.dx; sfxHitPaddle(); }

                if(ball.y - ball.r < 0) { ball.y = ball.r; ball.dy = -ball.dy; sfxHitPaddle(); }
                
                // Death (Floor)
                else if(ball.y - ball.r > canvas.height) {
                    lives--;
                    sfxLifeLost();
                    updateUI();
                    
                    const flash = document.getElementById('flash');
                    flash.style.opacity = 0.3;
                    setTimeout(() => flash.style.opacity = 0, 100);

                    if(lives <= 0) {
                        endGame();
                    } else {
                        // AUTO-LAUNCH: Reset ball and launch after 1s
                        ball.active = false;
                        ball.x = paddle.x + paddle.width/2;
                        ball.y = paddle.y - ball.r - 1;
                        ball.dx = 0; ball.dy = 0;
                        
                        setTimeout(() => {
                            if(!gameOver && lives > 0) {
                                ball.active = true;
                                ball.speed = ball.baseSpeed + (level * 0.5);
                                ball.dx = (Math.random() - 0.5) * 8;
                                ball.dy = -ball.speed;
                            }
                        }, 1500);
                    }
                }

                // Paddle Collision
                if(ball.y + ball.r >= paddle.y && 
                   ball.y - ball.r <= paddle.y + paddle.height &&
                   ball.x >= paddle.x && 
                   ball.x <= paddle.x + paddle.width) {
                    
                    if(ball.dy > 0) {
                        ball.dy = -Math.abs(ball.dy);
                        ball.y = paddle.y - ball.r - 1; 
                        
                        let hitPoint = (ball.x - (paddle.x + paddle.width/2)) / (paddle.width / 2);
                        let speed = Math.sqrt(ball.dx*ball.dx + ball.dy*ball.dy);
                        ball.dx = hitPoint * (speed * 0.8); 
                        
                        sfxHitPaddle();
                    }
                }

                // Brick Collision
                bricks.forEach(b => {
                    if(b.status === 1) {
                        if(ball.x > b.x && ball.x < b.x + b.w && ball.y > b.y && ball.y < b.y + b.h) {
                            ball.dy = -ball.dy;
                            b.hp--;
                            
                            if(b.hp <= 0) {
                                b.status = 0;
                                score += (10 * level);
                                updateUI();
                                for(let i=0; i<6; i++) particles.push({x: b.x+b.w/2, y: b.y+b.h/2, dx:(Math.random()-0.5)*8, dy:(Math.random()-0.5)*8, life:1, color: b.color});
                                sfxHitBrick();
                                
                                if(b.type !== 'REGULAR' && b.type !== 'HARD') {
                                    handlePowerUp(b.type);
                                }
                            } else {
                                sfxHitPaddle(); 
                            }
                            
                            if(bricks.every(x => x.status === 0)) {
                                level++;
                                initBricks();
                                ball.active = false;
                                resetBallPaddle();
                                timeLeft += 45;
                                updateUI();
                                startOverlay.style.display = 'flex';
                                startOverlay.querySelector('h3').innerText = "LEVEL CLEARED!";
                                startOverlay.querySelector('p').innerText = "[ CLICK FOR NEXT LEVEL ]";
                                sfxPowerUp(true);
                            }
                        }
                    }
                });
            } 
            else if (!ball.active && !gameOver) {
                ball.x = paddle.x + paddle.width/2;
                ball.y = paddle.y - ball.r - 2;
            }

            animationId = requestAnimationFrame(loop);
        }

        wrapper.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            const rx = e.clientX - rect.left;
            paddle.x = Math.max(0, Math.min(canvas.width - paddle.width, rx - paddle.width/2));
        });

        // GLOBAL CLICK TO START
        document.addEventListener('mousedown', e => {
            // Ignore clicks on buttons
            if(e.target.tagName === 'BUTTON' || e.target.tagName === 'A') return;
            
            // If start screen is visible, or if ball is waiting on paddle
            if(!ball.active && !gameOver && lives > 0) {
                startGame();
            }
        });

        function endGame() {
            gameOver = true;
            wrapper.style.cursor = "default";
            cancelAnimationFrame(animationId);
            clearInterval(timerInterval);
            document.getElementById('game-over-screen').style.display = 'flex';
            document.getElementById('final-score-display').innerText = score;
            startOverlay.style.display = 'none';
            saveScore(score);
            loadLeaderboard();
        }

        function saveScore(newScore) {
            let scores = JSON.parse(localStorage.getItem('civsocScores') || "[]");
            const date = new Date().toLocaleDateString('en-GB', { day: 'numeric', month: 'short' });
            scores.push({ score: newScore, date: date });
            scores.sort((a, b) => b.score - a.score);
            scores = scores.slice(0, 10);
            localStorage.setItem('civsocScores', JSON.stringify(scores));
        }

        function loadLeaderboard() {
            const list = document.getElementById('leaderboard-list');
            let scores = JSON.parse(localStorage.getItem('civsocScores') || "[]");
            list.innerHTML = "";
            if(scores.length===0) list.innerHTML = "<li style='text-align:center;color:#666'>No scores yet.</li>";
            scores.forEach((s, i) => {
                const li = document.createElement('li');
                li.innerHTML = `<span>#${i+1} ${s.date}</span> <span>${s.score}</span>`;
                list.appendChild(li);
            });
        }

        function resetGame() {
            document.getElementById('game-over-screen').style.display = 'none';
            startOverlay.style.display = 'flex';
            startOverlay.querySelector('h3').innerText = "READY?";
            startOverlay.querySelector('p').innerText = "[ CLICK TO LAUNCH ]";
            
            gameOver = false; gameActive = false;
            score = 0; lives = 3; timeLeft = 90; level = 1;
            if(timerInterval) clearInterval(timerInterval);
            paddle.width = 120;
            resetBallPaddle();
            initBricks();
            updateUI();
            
            cancelAnimationFrame(animationId);
            loop();
        }

        loadLeaderboard();
        resetGame();

    </script>
</body>
</html>