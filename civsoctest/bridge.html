<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CIVSOC GENERATIVE CAD V3.2</title>

    <link rel="icon" type="image/png" href="images/website/civsoclogo.png">
<link rel="apple-touch-icon" href="images/website/civsoclogo.png">
    <style>
        body { margin: 0; overflow: hidden; background-color: #0b1d2e; font-family: 'Courier New', monospace; }
        
        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between; padding: 30px;
            box-sizing: border-box;
        }

        .title-box {
            color: #ffffff;
            border-left: 2px solid #4fc3f7;
            padding-left: 15px;
            background: linear-gradient(to right, rgba(11, 29, 46, 0.6), transparent);
            backdrop-filter: blur(2px);
            max-width: 350px; /* Prevent it from stretching too far */
        }
        
        /* COMPACT TYPOGRAPHY */
        h1 { 
            margin: 0; 
            font-size: 1.2rem; /* Smaller Title */
            letter-spacing: 1px; 
            font-weight: 800; 
            text-transform: uppercase; 
            color: #4fc3f7; 
        }
        p { margin: 2px 0 0 0; font-size: 0.7rem; opacity: 0.7; }

        .stats-grid {
            display: grid; grid-template-columns: 1fr 1.2fr; gap: 5px; /* Tighter grid */
            margin-top: 8px; 
            font-size: 0.65rem; /* Smaller Data */
            color: #a0c4ff;
        }
        .stat-item span { color: white; font-weight: bold; }

        .exit-btn {
            pointer-events: auto; align-self: flex-end; background: transparent;
            color: #4fc3f7; border: 1px solid #4fc3f7; padding: 8px 20px;
            text-decoration: none; font-weight: bold; text-transform: uppercase;
            font-size: 0.8rem;
            transition: all 0.3s; backdrop-filter: blur(2px);
        }
        .exit-btn:hover { background: #4fc3f7; color: #0b1d2e; box-shadow: 0 0 15px rgba(79, 195, 247, 0.4); }

        .regen-btn {
            pointer-events: auto; margin-top: 10px; background: rgba(79, 195, 247, 0.1);
            color: #ffffff; border: 1px solid rgba(255,255,255,0.3); padding: 6px 12px;
            cursor: pointer; font-family: inherit; font-weight: bold; text-transform: uppercase;
            font-size: 0.7rem;
        }
        .regen-btn:hover { background: #ffffff; color: #000; }

        canvas { display: block; } 
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div class="ui-layer">
        <div class="title-box">
            <h1>STRUCTURAL ENGINE</h1>
            <p>ID: <span id="seed-val">...</span></p>
            
            <div class="stats-grid" id="bridge-stats">
                </div>

            <button class="regen-btn" onclick="location.reload()">GENERATE NEW</button>
        </div>
        <a href="index.html" class="exit-btn">CLOSE</a>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 1. PARAMETRIC ENGINE ---
        function randomRange(min, max) { return Math.random() * (max - min) + min; }
        function randomInt(min, max) { return Math.floor(Math.random() * (max - min + 1) + min); }
        function pick(arr) { return arr[Math.floor(Math.random() * arr.length)]; }

        // CONFIGURATION
        const TYPES = ['SUSPENSION', 'CABLE-STAYED', 'TRUSS', 'ARCH', 'BEAM'];
        const TYPE = pick(TYPES);
        
        // Unique parameters
        const config = {
            type: TYPE,
            spanLength: randomRange(200, 500),
            deckWidth: randomRange(12, 24),
            deckHeight: randomRange(25, 50),
            towerHeight: randomRange(80, 160),
            trussStyle: pick(['WARREN', 'PRATT']), 
            trussPosition: pick(['THROUGH', 'DECK']),
            archCount: (TYPE === 'ARCH') ? randomInt(1, 4) : 1,
            pierCount: (TYPE === 'BEAM') ? randomInt(3, 6) : 0,
            color: 0xffffff,
            accentColor: 0x4fc3f7
        };

        // UI UPDATE
        document.getElementById('seed-val').innerText = Math.random().toString(36).substr(2, 8).toUpperCase();
        let statsHtml = `
            <div class="stat-item">TYPE: <span>${config.type}</span></div>
            <div class="stat-item">SPAN: <span>${config.spanLength.toFixed(0)}m</span></div>
            <div class="stat-item">ELEV: <span>${config.deckHeight.toFixed(0)}m</span></div>
        `;
        
        if(TYPE === 'TRUSS') statsHtml += `<div class="stat-item">CFG: <span>${config.trussStyle}</span></div>`;
        if(TYPE === 'ARCH') statsHtml += `<div class="stat-item">ARCHES: <span>${config.archCount}</span></div>`;
        if(TYPE === 'BEAM') statsHtml += `<div class="stat-item">PIERS: <span>${config.pierCount}</span></div>`;
        
        document.getElementById('bridge-stats').innerHTML = statsHtml;

        // --- 2. THREE.JS SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0b1d2e);
        scene.fog = new THREE.FogExp2(0x0b1d2e, 0.0015);

        const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 4000);
        camera.position.set(300, 150, 400);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; controls.autoRotate = true; controls.autoRotateSpeed = 0.8;
        controls.maxPolarAngle = Math.PI / 2 - 0.1; 

        // --- 3. MATERIALS ---
        const ghostMat = new THREE.MeshBasicMaterial({ 
            color: config.color, transparent: true, opacity: 0.03, 
            side: THREE.DoubleSide, depthWrite: false 
        });

        const lineMat = new THREE.LineBasicMaterial({ color: config.color, linewidth: 1 });
        const accentMat = new THREE.LineBasicMaterial({ color: config.accentColor, linewidth: 2 });
        const roadMat = new THREE.MeshBasicMaterial({ color: 0x1a1a1a });

        // --- 4. HELPERS ---
        function createBox(w, h, d, x, y, z, mat = lineMat, rotX = 0, rotZ = 0) {
            const geo = new THREE.BoxGeometry(w, h, d);
            const mesh = new THREE.Mesh(geo, ghostMat);
            mesh.position.set(x, y, z);
            mesh.rotation.x = rotX;
            mesh.rotation.z = rotZ;
            const edges = new THREE.EdgesGeometry(geo);
            const lines = new THREE.LineSegments(edges, mat);
            mesh.add(lines);
            scene.add(mesh);
            return mesh;
        }

        // --- 5. GENERATORS ---

        function buildEnvironment() {
            const grid = new THREE.GridHelper(2000, 100, 0x4fc3f7, 0x1a3a5a);
            grid.position.y = -20;
            scene.add(grid);
            
            const planeGeo = new THREE.PlaneGeometry(2000, 2000);
            const plane = new THREE.Mesh(planeGeo, new THREE.MeshBasicMaterial({ color: 0x0b1d2e, transparent: true, opacity: 0.9 }));
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = -21;
            scene.add(plane);
        }

        function buildDeck(length) {
            const road = new THREE.Mesh(new THREE.BoxGeometry(length, 1, config.deckWidth), roadMat);
            road.position.set(0, config.deckHeight, 0);
            scene.add(road);
            
            const depth = config.type === 'TRUSS' && config.trussPosition === 'DECK' ? 1 : 4;
            createBox(length, depth, config.deckWidth, 0, config.deckHeight - (depth/2), 0);
            return length;
        }

        // === TYPE: SUSPENSION ===
        function genSuspension() {
            const span = config.spanLength;
            const towerX = span / 2;
            const tW = 10, tD = 10;
            [towerX, -towerX].forEach(x => {
                createBox(tW, config.towerHeight, tD, x, config.towerHeight/2, config.deckWidth/1.5);
                createBox(tW, config.towerHeight, tD, x, config.towerHeight/2, -config.deckWidth/1.5);
                createBox(tW-2, 2, config.deckWidth*2, x, config.towerHeight*0.8, 0);
                createBox(tW-2, 2, config.deckWidth*2, x, config.deckHeight + 20, 0);
            });

            const cableZ = config.deckWidth/1.5;
            const sagY = config.deckHeight + (config.towerHeight - config.deckHeight) * 0.2;
            [cableZ, -cableZ].forEach(z => {
                const curve = new THREE.QuadraticBezierCurve3(
                    new THREE.Vector3(-towerX, config.towerHeight, z),
                    new THREE.Vector3(0, sagY, z),
                    new THREE.Vector3(towerX, config.towerHeight, z)
                );
                const points = curve.getPoints(50);
                const cable = new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), accentMat);
                scene.add(cable);

                const anchorPointsLeft = [new THREE.Vector3(-towerX, config.towerHeight, z), new THREE.Vector3(-towerX*1.6, -10, z)];
                const anchorPointsRight = [new THREE.Vector3(towerX, config.towerHeight, z), new THREE.Vector3(towerX*1.6, -10, z)];
                scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(anchorPointsLeft), accentMat));
                scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(anchorPointsRight), accentMat));

                for(let i=1; i<50; i+=2) {
                    const p = points[i];
                    if(p.y > config.deckHeight) {
                        const vGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(p.x, p.y, p.z), new THREE.Vector3(p.x, config.deckHeight, p.z)]);
                        scene.add(new THREE.Line(vGeo, lineMat));
                    }
                }
            });
            buildDeck(config.spanLength * 1.6);
        }

        // === TYPE: CABLE STAYED ===
        function genCableStayed() {
            const span = config.spanLength;
            const pylonX = span / 3; 
            
            [pylonX, -pylonX].forEach(x => {
                const h = config.towerHeight;
                const lean = 0.15;
                const zOffset = config.deckWidth / 1.5;
                
                createBox(6, h, 6, x, h/2, zOffset/2, lineMat, lean, 0);
                createBox(6, h, 6, x, h/2, -zOffset/2, lineMat, -lean, 0);
                createBox(8, 4, 8, x, h * 0.95, 0, lineMat);

                const cableCount = 7;
                for(let i=1; i<=cableCount; i++) {
                    const attachY = h * 0.5 + (i * (h * 0.4) / cableCount);
                    const dist = (span / 2.5) * (i / cableCount);
                    
                    const ptTop = new THREE.Vector3(x, attachY, 0);
                    const ptDeckFront = new THREE.Vector3(x > 0 ? x - dist : x + dist, config.deckHeight, 0);
                    scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([ptTop, ptDeckFront]), accentMat)); 
                    
                    const ptDeckBack = new THREE.Vector3(x > 0 ? x + (dist*0.6) : x - (dist*0.6), config.deckHeight, 0);
                    scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([ptTop, ptDeckBack]), lineMat));
                }
            });

            buildDeck(config.spanLength * 1.2);
        }

        // === TYPE: TRUSS ===
        function genTruss() {
            const segLen = 20;
            const height = 25;
            const totalLen = config.spanLength;
            const segments = Math.floor(totalLen / segLen);
            const startX = -(segments * segLen) / 2;

            let botY = config.deckHeight;
            let topY = config.deckHeight + height;
            if(config.trussPosition === 'DECK') {
                topY = config.deckHeight;
                botY = config.deckHeight - height;
            }

            [config.deckWidth/2, -config.deckWidth/2].forEach(z => {
                createBox(segments*segLen, 2, 2, 0, topY, z, accentMat);
                createBox(segments*segLen, 2, 2, 0, botY, z, accentMat);

                for(let i=0; i<=segments; i++) {
                    const x = startX + i * segLen;
                    const vPts = [new THREE.Vector3(x, botY, z), new THREE.Vector3(x, topY, z)];
                    scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(vPts), lineMat));

                    if(i < segments) {
                        let p1, p2;
                        if (config.trussStyle === 'WARREN') {
                            if (i % 2 === 0) { p1 = new THREE.Vector3(x, botY, z); p2 = new THREE.Vector3(x+segLen, topY, z); }
                            else { p1 = new THREE.Vector3(x, topY, z); p2 = new THREE.Vector3(x+segLen, botY, z); }
                        } else { 
                            p1 = new THREE.Vector3(x, botY, z); p2 = new THREE.Vector3(x+segLen, topY, z);
                        }
                        scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([p1, p2]), lineMat));
                    }
                }
            });

            for(let i=0; i<=segments; i++) {
                const x = startX + i * segLen;
                const topPts = [new THREE.Vector3(x, topY, config.deckWidth/2), new THREE.Vector3(x, topY, -config.deckWidth/2)];
                scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(topPts), lineMat));
            }

            createBox(10, config.deckHeight, 30, startX, config.deckHeight/2, 0);
            createBox(10, config.deckHeight, 30, -startX, config.deckHeight/2, 0);
            buildDeck(segments * segLen);
        }

        // === TYPE: ARCH ===
        function genArch() {
            const totalLen = config.spanLength;
            const archCount = config.archCount;
            const archSpan = totalLen / archCount;
            const archRise = archSpan * 0.4;

            for(let i=0; i<archCount; i++) {
                const centerX = -(totalLen/2) + (archSpan/2) + (i * archSpan);
                
                [config.deckWidth/2, -config.deckWidth/2].forEach(z => {
                    const curve = new THREE.QuadraticBezierCurve3(
                        new THREE.Vector3(centerX - archSpan/2, -10, z),
                        new THREE.Vector3(centerX, config.deckHeight + archRise, z),
                        new THREE.Vector3(centerX + archSpan/2, -10, z)
                    );
                    const points = curve.getPoints(20);
                    points.forEach((p, idx) => {
                        if(idx < points.length-1) {
                           const p2 = points[idx+1];
                           if(p.y < config.deckHeight + 5) {
                               scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([p, p2]), accentMat));
                           }
                        }
                        if(p.y < config.deckHeight && idx % 2 === 0) {
                            const colGeo = new THREE.BufferGeometry().setFromPoints([
                                new THREE.Vector3(p.x, p.y, z), new THREE.Vector3(p.x, config.deckHeight, z)
                            ]);
                            scene.add(new THREE.Line(colGeo, lineMat));
                        }
                    });
                });

                if(i < archCount - 1) {
                    createBox(5, config.deckHeight + 10, config.deckWidth + 5, centerX + archSpan/2, config.deckHeight/2, 0);
                }
            }
            createBox(20, config.deckHeight, config.deckWidth+10, -totalLen/2 - 10, config.deckHeight/2, 0);
            createBox(20, config.deckHeight, config.deckWidth+10, totalLen/2 + 10, config.deckHeight/2, 0);
            buildDeck(totalLen + 40);
        }

        // === TYPE: BEAM ===
        function genBeam() {
            const totalLen = config.spanLength;
            const pierCount = config.pierCount;
            const spacing = totalLen / (pierCount + 1);

            for(let i=1; i<=pierCount; i++) {
                const x = -(totalLen/2) + (spacing * i);
                createBox(6, config.deckHeight - 5, 8, x, (config.deckHeight-5)/2, 0);
                createBox(8, 4, config.deckWidth * 1.2, x, config.deckHeight - 2, 0);
            }
            const girderDepth = 5;
            createBox(totalLen + 20, girderDepth, config.deckWidth, 0, config.deckHeight - (girderDepth/2), 0, accentMat);
            createBox(10, config.deckHeight, config.deckWidth+5, -totalLen/2 - 5, config.deckHeight/2, 0);
            createBox(10, config.deckHeight, config.deckWidth+5, totalLen/2 + 5, config.deckHeight/2, 0);
            buildDeck(totalLen + 20);
        }

        // --- INIT ---
        buildEnvironment();

        switch(config.type) {
            case 'SUSPENSION': genSuspension(); break;
            case 'CABLE-STAYED': genCableStayed(); break;
            case 'TRUSS': genTruss(); break;
            case 'ARCH': genArch(); break;
            case 'BEAM': genBeam(); break;
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        controls.addEventListener('start', () => controls.autoRotate = false);

        animate();
    </script>
</body>
</html>